<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimal Terminal Client</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
    <link href="https://cdn.jsdelivr.net/npm/@vscode/codicons@0.0.36/dist/codicon.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
        }

        body {
            background: #0f0f0f;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            background: #1e1e1e;
            border-bottom: 1px solid #333;
            padding: 8px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 40px;
            flex-shrink: 0;
        }
        
        .title {
            color: #007acc;
            font-size: 13px;
            font-weight: 500;
        }
        
        .terminal-container {
            flex: 1;
            background: #0f0f0f;
            overflow: hidden;
            position: relative;
            padding: 8px;
        }
        
        #terminal {
            height: 100%;
            width: 100%;
        }
        
        .xterm {
            height: 100%;
            width: 100%;
        }
        
        .connection-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .modal-content {
            background: #1e1e1e;
            padding: 24px;
            border-radius: 8px;
            border: 1px solid #333;
            width: 600px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            position: relative; /* Added for close button positioning */
        }
        
        .modal-title {
            color: #fff;
            font-size: 18px;
            text-align: center;
        }

        .close-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #2d2d2d;
            border: none;
            color: #ccc;
            font-size: 20px;
            cursor: pointer;
            padding: 5px;
        }

        .close-button:hover {
            color: #fff;
        }

        .connection-step {
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: flex-end; /* Right-align buttons */
        }

        .connection-step .form-input {
            flex-grow: 1;
        }
        
        .form-input {
            padding: 8px;
            background: #2d2d2d;
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
            font-size: 13px;
        }
        
        .form-input:focus {
            outline: none;
            border-color: #007acc;
        }

        .step-button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            width: 120px;
            text-align: center;
        }

        .step-button.primary {
            background: #007acc;
            color: white;
        }

        .step-button.secondary {
            background: #2d2d2d;
            color: #ccc;
        }

        .step-button.success {
            background: #51cf66;
            color: white;
            cursor: default;
        }

        .step-button:hover:not(.success) {
            opacity: 0.9;
        }

        .shell-type-button {
            padding: 8px 12px;
            border: 1px solid #444;
            border-radius: 4px;
            background: #2d2d2d;
            color: #ccc;
            cursor: pointer;
            font-size: 13px;
            transition: background-color 0.2s, border-color 0.2s;
        }

        .shell-type-button.selected {
            background: #007acc;
            border-color: #007acc;
            color: white;
        }

        .shell-type-button:hover:not(.selected) {
            background: #3a3a3a;
            border-color: #555;
        }

        .codespace-list {
            border: 1px solid #333;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 8px;
        }

        .codespace-item {
            padding: 12px;
            cursor: pointer;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #cccccc; /* Ensure main text is light */
        }

        .codespace-item:last-child {
            border-bottom: none;
        }

        .codespace-item:hover {
            background: #2d2d2d;
        }

        .codespace-item.selected {
            background: #007acc;
            color: white;
        }

        .codespace-repo {
            font-size: 11px;
            color: #aaaaaa; /* Lighter grey for better contrast */
        }

        .codespace-item.selected .codespace-repo {
            color: #ddd;
        }

        .info-box {
            background: #2d2d2d;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 12px;
            font-size: 12px;
            color: #ccc;
            min-height: 40px;
            white-space: pre-wrap;
        }

        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 16px;
        }
        
        .hidden {
            display: none;
        }

        .statusbar-item {
            height: 22px;
            line-height: 22px;
            cursor: default;
            color: #fff;
            padding: 0 8px;
            white-space: nowrap;
            -webkit-user-select: none;
            user-select: none;
            background-color: #007acc;
        }
        .statusbar-item-label {
            color: #fff;
            text-decoration: none;
        }

        .statusbar-item.light-grey {
            background-color: #3c3c3c; /* VS Code status bar grey */
        }

        .statusbar-item.light-grey .statusbar-item-label {
            color: #f0f0f0;
        }

        .status-bar-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            display: flex;
            flex-direction: row;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="title">Minimal Terminal Client</div>
        <div class="controls">
             <button class="control-button step-button primary" id="clearTerminalButton">Clear</button>
             <button class="control-button step-button primary" id="openGeminiButton">Open Gemini</button>
        </div>
    </div>
    
    <div class="terminal-container">
        <div id="terminal"></div>
    </div>
    
    <div class="connection-modal" id="connectionModal">
        <div class="modal-content">
            <h3 class="modal-title">Connect to Remote Terminal</h3>
            <button class="close-button" onclick="hideConnectionModal()">&times;</button>
            
            <div class="connection-step">
                <input type="text" class="form-input" id="serverUrl" value="ws://localhost:3001" placeholder="Server URL">
                <button class="step-button primary" id="connectServerButton">Connect</button>
            </div>

            <div class="connection-step">
                <input type="password" class="form-input" id="githubToken" placeholder="GitHub Token">
                <button class="step-button secondary" id="authenticateButton" disabled>Authenticate</button>
            </div>

            

            <div class="codespace-list" id="codespaceList">
                <!-- Codespaces will be populated here -->
            </div>

            <div class="connection-step" style="justify-content: flex-end; gap: 16px;">
                <label style="color: #ccc; font-size: 13px;">Shell Type:</label>
                <button class="shell-type-button selected" data-shell-type="default">Default</button>
                
                <button class="shell-type-button" data-shell-type="google">Google</button>
            </div>

            <div class="connection-step hidden" id="geminiApiKeyInput" style="justify-content: flex-end; gap: 16px;">
                <input type="password" class="form-input" id="geminiApiKey" placeholder="Gemini API Key">
            </div>

            <div class="info-box" id="infoBox">
                Welcome! Please connect to the server to begin.
            </div>

            <div class="modal-buttons">
                <button class="step-button secondary" onclick="hideConnectionModal()">Close</button>
                <button class="step-button primary" id="connectCodespaceButton" disabled>Connect to Codespace</button>
            </div>
        </div>
    </div>

    <div class="status-bar-container">
        <div class="statusbar-item remote-kind has-background-color" id="remote-status">
            <a class="statusbar-item-label" role="button">
                <span class="codicon codicon-remote"></span>
                <span id="remote-status-text">Open Remote</span>
            </a>
        </div>

        <div class="statusbar-item light-grey" id="status.forwardedPorts" aria-label="No Ports Forwarded" custom-hover="true">
            <a class="statusbar-item-label" role="button" tabindex="-1" aria-label="No Ports Forwarded">
                <span class="codicon codicon-radio-tower"></span>
                <span id="forwarded-ports-count">0</span>
            </a>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>
    <script>
        class MinimalTerminalClient {
            constructor() {
                this.terminal = null;
                this.socket = null;
                this.fitAddon = null;
                this.isConnected = false;
                this.isIntentionalDisconnect = false;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.currentCodespaceName = null;
                this.currentCodespaceState = null;
                this.currentRepositoryFullName = null;
                this.githubToken = null;
                this.statusQueue = [];
                this.isProcessingStatusQueue = false;
                
                this.init();
            }

            processStatusQueue() {
                if (this.statusQueue.length === 0) {
                    this.isProcessingStatusQueue = false;
                    return;
                }

                this.isProcessingStatusQueue = true;
                const message = this.statusQueue.shift();
                const remoteStatusText = document.getElementById('remote-status-text');
                remoteStatusText.textContent = message;

                setTimeout(() => {
                    this.processStatusQueue();
                }, 3000);
            }

            addStatusMessage(message) {
                this.statusQueue.push(message);
                if (!this.isProcessingStatusQueue) {
                    this.processStatusQueue();
                }
            }
            
            init() {
                // Initialize xterm.js terminal
                this.terminal = new Terminal({
                    cursorBlink: true,
                    cursorStyle: 'block',
                    theme: {
                        background: '#0f0f0f',
                        foreground: '#ffffff',
                        cursor: '#ffffff',
                        selection: '#ffffff20',
                        black: '#000000',
                        red: '#cd3131',
                        green: '#0dbc79',
                        yellow: '#e5e510',
                        blue: '#2472c8',
                        magenta: '#bc3fbc',
                        cyan: '#11a8cd',
                        white: '#e5e5e5',
                        brightBlack: '#666666',
                        brightRed: '#f14c4c',
                        brightGreen: '#23d18b',
                        brightYellow: '#f5f543',
                        brightBlue: '#3b8eea',
                        brightMagenta: '#d670d6',
                        brightCyan: '#29b8db',
                        brightWhite: '#e5e5e5'
                    },
                    fontSize: 14,
                    fontFamily: 'Monaco, Menlo, "Ubuntu Mono", monospace',
                    lineHeight: 1.2
                });
                
                // Initialize fit addon for proper sizing
                this.fitAddon = new FitAddon.FitAddon();
                this.terminal.loadAddon(this.fitAddon);
                
                // Open terminal in the container
                const terminalContainer = document.getElementById('terminal');
                this.terminal.open(terminalContainer);
                
                // Delay fit to ensure container has rendered its size
                setTimeout(() => {
                    console.log(`[DEBUG] Before fit: terminalContainer.offsetHeight=${terminalContainer.offsetHeight}, terminalContainer.offsetWidth=${terminalContainer.offsetWidth}`);
                    this.fitAddon.fit();
                    console.log(`[DEBUG] After fit: cols=${this.terminal.cols}, rows=${this.terminal.rows}`);
                }, 100); // Small delay
                
                // Handle terminal input
                this.terminal.onData((data) => {
                    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                        this.socket.send(JSON.stringify({
                            type: 'input',
                            data: data
                        }));
                    }
                });
                
                // Handle window resize and container resize
                const resizeObserver = new ResizeObserver(entries => {
                    for (let entry of entries) {
                        if (entry.target === terminalContainer) {
                            this.fitAddon.fit();
                            console.log(`[DEBUG] Terminal resized by ResizeObserver: cols=${this.terminal.cols}, rows=${this.terminal.rows}`);
                        }
                    }
                });
                resizeObserver.observe(terminalContainer);

                window.addEventListener('resize', () => {
                    this.fitAddon.fit();
                    console.log(`[DEBUG] Terminal resized by window resize: cols=${this.terminal.cols}, rows=${this.terminal.rows}`);
                });
                
                // Welcome message
                // this.terminal.writeln('\x1b[1;34mMinimal Terminal Client\x1b[0m');
                // this.terminal.writeln('\x1b[90mClick "Connect" to establish a connection to a remote terminal.\x1b[0m');
                // this.terminal.writeln('');
            }
            
            connect(url, token = '') {
                if (this.socket) {
                    this.socket.close();
                }
                
                this.updateInfoBox('Connecting to server...');
                const connectServerButton = document.getElementById('connectServerButton');
                connectServerButton.textContent = 'Connecting...';
                connectServerButton.disabled = true;
                connectServerButton.classList.remove('success', 'error');
                
                try {
                    this.socket = new WebSocket(url);
                    
                    this.socket.onopen = () => {
                        this.isConnected = true;
                        this.reconnectAttempts = 0;
                        this.updateInfoBox('Successfully connected to server. Please authenticate.');
                        connectServerButton.textContent = 'Connected';
                        connectServerButton.classList.add('success');
                        document.getElementById('githubToken').disabled = false;
                        document.getElementById('authenticateButton').disabled = false;
                        
                        // Send authentication if provided
                        if (token) {
                            this.authenticate(token);
                        } else if (this.githubToken) {
                            this.authenticate(this.githubToken);
                        }
                    };
                    
                    this.socket.onmessage = (event) => {
                        try {
                            const message = JSON.parse(event.data);
                            this.handleMessage(message);
                        } catch (e) {
                            // Handle raw data
                            this.terminal.write(event.data);
                        }
                    };
                    
                    this.socket.onclose = () => {
                        this.isConnected = false;
                        this.updateStatus('Disconnected', false);
                        this.updateInfoBox('Connection closed.', true);
                        connectServerButton.textContent = 'Reconnect';
                        connectServerButton.classList.add('error');
                        connectServerButton.disabled = false;
                        document.getElementById('githubToken').disabled = true;
                        document.getElementById('authenticateButton').textContent = 'Authenticate';
                        document.getElementById('authenticateButton').classList.remove('success');
                        document.getElementById('authenticateButton').disabled = true;
                        document.getElementById('connectCodespaceButton').textContent = 'Connect to Codespace';
                        document.getElementById('connectCodespaceButton').classList.remove('success');
                        document.getElementById('connectCodespaceButton').disabled = true;
                        
                        // Auto-reconnect logic
                        if (!this.isIntentionalDisconnect && this.reconnectAttempts < this.maxReconnectAttempts) {
                            this.reconnectAttempts++;
                            this.addStatusMessage(`Reconnecting... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
                            setTimeout(() => this.connect(url, this.githubToken), 2000);
                        } else {
                            this.isIntentionalDisconnect = false; // Reset the flag
                        }
                    };
                    
                    this.socket.onerror = (error) => {
                        this.updateStatus('Connection Error', false);
                        this.updateInfoBox('Connection error. Please check the server URL and try again.', true);
                        connectServerButton.textContent = 'Retry';
                        connectServerButton.classList.add('error');
                        connectServerButton.disabled = false;
                    };
                    
                } catch (error) {
                    this.updateStatus('Connection Error', false);
                    this.updateInfoBox('Invalid WebSocket URL.', true);
                    connectServerButton.textContent = 'Retry';
                    connectServerButton.classList.add('error');
                    connectServerButton.disabled = false;
                }
            }

            authenticate(token) {
                this.githubToken = token;
                if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                    this.socket.send(JSON.stringify({
                        type: 'authenticate',
                        token: token
                    }));
                    this.updateInfoBox('Authenticating...');
                    document.getElementById('authenticateButton').textContent = 'Authenticating...';
                    document.getElementById('authenticateButton').disabled = true;
                    document.getElementById('authenticateButton').classList.remove('error');
                } else {
                    this.updateInfoBox('Not connected to server. Please connect first.', true);
                }
            }

            listCodespaces() {
                if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                    this.socket.send(JSON.stringify({
                        type: 'list_codespaces'
                    }));
                    this.updateInfoBox('Requesting codespaces list...');
                } else {
                    this.updateInfoBox('Not connected to server. Please connect first.', true);
                }
            }

            updateInfoBox(message, isError = false) {
                const infoBox = document.getElementById('infoBox');
                infoBox.textContent = message;
                if (isError) {
                    infoBox.style.color = '#ff6b6b';
                } else {
                    infoBox.style.color = '#ccc';
                }
            }

            connectToCodespace(codespaceName) {
                if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                    this.socket.send(JSON.stringify({
                        type: 'connect_codespace',
                        codespace_name: codespaceName
                    }));
                    this.updateInfoBox(`Connecting to codespace: ${codespaceName}...`);
                    document.getElementById('connectCodespaceButton').textContent = 'Connecting...';
                    document.getElementById('connectCodespaceButton').disabled = true;
                    document.getElementById('connectCodespaceButton').classList.remove('error');
                } else {
                    this.updateInfoBox('Not connected to server. Please connect first.', true);
                }
            }

            disconnectFromCodespace() {
                if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                    this.socket.send(JSON.stringify({
                        type: 'disconnect_codespace'
                    }));
                    this.updateInfoBox('Disconnecting from codespace...');
                } else {
                    this.updateInfoBox('Not connected to server. Please connect first.', true);
                }
            }

            startCodespace(codespaceName) {
                if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                    this.socket.send(JSON.stringify({
                        type: 'start_codespace',
                        codespace_name: codespaceName
                    }));
                    this.updateInfoBox(`Starting codespace: ${codespaceName}...`);
                } else {
                    this.updateInfoBox('Not connected to server. Please connect first.', true);
                }
            }

            stopCodespace(codespaceName) {
                if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                    this.socket.send(JSON.stringify({
                        type: 'stop_codespace',
                        codespace_name: codespaceName
                    }));
                    this.updateInfoBox(`Stopping codespace: ${codespaceName}...`);
                } else {
                    this.updateInfoBox('Not connected to server. Please connect first.', true);
                }
            }
            
            handleMessage(message) {
                switch (message.type) {
                    case 'output':
                        this.terminal.write(message.data);
                        break;
                    case 'error':
                        this.updateInfoBox(`Error: ${message.message}`, true);
                        if (message.message === 'Bad credentials') {
                            const authenticateButton = document.getElementById('authenticateButton');
                            authenticateButton.textContent = 'Retry';
                            authenticateButton.classList.add('error');
                            authenticateButton.disabled = false;
                        } else if (message.message.includes('Terminal session ended')) {
                            this.addStatusMessage('Terminal session ended.');
                            const connectCodespaceButton = document.getElementById('connectCodespaceButton');
                            connectCodespaceButton.textContent = 'Reconnect';
                            connectCodespaceButton.classList.add('error');
                            connectCodespaceButton.disabled = false;
                        }
                        break;
                    case 'authenticated':
                        this.updateInfoBox('Authenticated successfully. Fetching codespaces...');
                        const authenticateButton = document.getElementById('authenticateButton');
                        authenticateButton.textContent = 'Authenticated';
                        authenticateButton.classList.add('success');
                        this.listCodespaces();
                        // If we were previously connected to a codespace, try to reconnect
                        if (this.currentCodespaceName) {
                            this.connectToCodespace(this.currentCodespaceName);
                        }
                        break;
                    case 'codespaces_list':
                        const codespaces = message.data;
                        const codespaceList = document.getElementById('codespaceList');
                        codespaceList.innerHTML = ''; // Clear existing options
                        if (codespaces && codespaces.length > 0) {
                            this.updateInfoBox(`Found ${codespaces.length} codespace(s). Please select one to connect.`);
                            codespaces.forEach(codespace => {
                                const item = document.createElement('div');
                                item.classList.add('codespace-item');
                                item.dataset.codespaceName = codespace.name;

                                const codespaceNameParts = codespace.name.split('-');
                                codespaceNameParts.pop();
                                const prettyName = codespaceNameParts.join(' ');

                                item.innerHTML = `
                                    <span>${prettyName}</span>
                                    <span class="codespace-repo">${codespace.repository.full_name}</span>
                                `;

                                item.addEventListener('click', () => {
                                    const allItems = document.querySelectorAll('.codespace-item');
                                    allItems.forEach(i => i.classList.remove('selected'));
                                    item.classList.add('selected');
                                    document.getElementById('connectCodespaceButton').disabled = false;
                                    document.getElementById('connectCodespaceButton').textContent = 'Connect to Codespace';
                                    document.getElementById('connectCodespaceButton').classList.remove('success', 'error');
                                });
                                codespaceList.appendChild(item);
                            });
                        } else {
                            this.updateInfoBox('No codespaces found.', true);
                        }
                        break;
                    case 'codespace_state':
                        this.currentCodespaceName = message.codespace_name;
                        this.currentCodespaceState = message.state;
                        this.currentRepositoryFullName = message.repository_full_name;
                        this.updateCodespaceUI(message.state);
                        if (message.state === 'Connected') {
                            hideConnectionModal();
                            const connectCodespaceButton = document.getElementById('connectCodespaceButton');
                            connectCodespaceButton.textContent = 'Connected';
                            connectCodespaceButton.classList.add('success');
                        }
                        break;
                    case 'codespace_connection_status':
                        this.currentCodespaceName = message.codespace_name;
                        this.currentCodespaceState = message.state;
                        this.updateCodespaceUI(message.state);
                        break;
                    default:
                        console.log('Unknown message type:', message);
                }
            }
            
            updateStatus(text, connected) {
                const remoteStatusText = document.getElementById('remote-status-text');
                const forwardedPortsCount = document.getElementById('forwarded-ports-count');

                if (connected) {
                    // Don't change status text here, it will be updated by updateCodespaceUI
                } else {
                    remoteStatusText.textContent = 'Not Connected';
                    forwardedPortsCount.textContent = '0';
                    showConnectionModal();
                }
            }

            updateCodespaceUI(state) {
                const connectCodespaceButton = document.getElementById('connectCodespaceButton');
                const remoteStatus = document.getElementById('remote-status');
                const remoteStatusText = document.getElementById('remote-status-text');

                if (state === 'Connected') {
                    const codespaceNameParts = this.currentCodespaceName.split('-');
                    codespaceNameParts.pop(); // Omit the last word
                    const formattedCodespaceName = codespaceNameParts.join(' ');

                    remoteStatusText.textContent = `Connected: ${formattedCodespaceName}`;
                    remoteStatus.title = `Editing on '${formattedCodespaceName}' (${this.currentRepositoryFullName})`;
                    hideConnectionModal();
                } else if (state === 'Shutdown') {
                    remoteStatusText.textContent = 'Authenticated';
                } else if (state === 'Starting') {
                    remoteStatusText.textContent = 'Authenticated';
                } else if (state === 'Stopping') {
                    remoteStatusText.textContent = 'Authenticated';
                } else {
                    // Default or Disconnected state
                    remoteStatusText.textContent = 'Not Connected';
                }
            }
            
            clear() {
                this.terminal.clear();
            }

            reconnect() {
                const url = document.getElementById('serverUrl').value;
                this.connect(url, this.githubToken);
            }
        }
        
        // Global terminal client instance
        let terminalClient;
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            terminalClient = new MinimalTerminalClient();

            const remoteStatus = document.getElementById('remote-status');
            remoteStatus.addEventListener('click', () => {
                showConnectionModal();
            });

            const connectServerButton = document.getElementById('connectServerButton');
            const authenticateButton = document.getElementById('authenticateButton');
            const connectCodespaceButton = document.getElementById('connectCodespaceButton');

            connectServerButton.addEventListener('click', () => {
                const url = document.getElementById('serverUrl').value;
                if (connectServerButton.textContent === 'Reconnect') {
                    terminalClient.reconnect();
                } else {
                    terminalClient.connect(url);
                }
            });

            authenticateButton.addEventListener('click', () => {
                const token = document.getElementById('githubToken').value;
                if (token) {
                    terminalClient.authenticate(token);
                } else {
                    terminalClient.updateInfoBox('Please enter a GitHub Token.', true);
                }
            });

            connectCodespaceButton.addEventListener('click', () => {
                const selectedCodespace = document.querySelector('.codespace-item.selected');
                if (selectedCodespace) {
                    const codespaceName = selectedCodespace.dataset.codespaceName;
                    terminalClient.connectToCodespace(codespaceName);
                } else {
                    terminalClient.updateInfoBox('Please select a codespace.', true);
                }
            });

            // Add event listeners for the new buttons
            document.getElementById('clearTerminalButton').addEventListener('click', () => {
                terminalClient.clear();
            });

            document.getElementById('openGeminiButton').addEventListener('click', () => {
                const geminiApiKey = document.getElementById('geminiApiKey').value;
                const googleShellSelected = document.querySelector('.shell-type-button[data-shell-type="google"]').classList.contains('selected');
                let command = 'npx --yes https://github.com/google-gemini/gemini-cli';

                if (googleShellSelected && geminiApiKey) {
                    command = `export GEMINI_API_KEY=${geminiApiKey} && ${command}`;
                }
                terminalClient.terminal.writeln(command);
            });

            // Handle shell type selection
            const shellTypeButtons = document.querySelectorAll('.shell-type-button');
            const geminiApiKeyInput = document.getElementById('geminiApiKeyInput');

            shellTypeButtons.forEach(button => {
                button.addEventListener('click', () => {
                    shellTypeButtons.forEach(btn => btn.classList.remove('selected'));
                    button.classList.add('selected');

                    if (button.dataset.shellType === 'google') {
                        geminiApiKeyInput.classList.remove('hidden');
                    } else {
                        geminiApiKeyInput.classList.add('hidden');
                    }
                });
            });
        });
        
        // Modal functions
        function showConnectionModal() {
            document.getElementById('connectionModal').classList.remove('hidden');
        }
        
        function hideConnectionModal() {
            document.getElementById('connectionModal').classList.add('hidden');
        }
        
        // Handle Enter key in modal
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !document.getElementById('connectionModal').classList.contains('hidden')) {
                // Determine which step is active and trigger the corresponding button
                const connectServerButton = document.getElementById('connectServerButton');
                const authenticateButton = document.getElementById('authenticateButton');
                const connectCodespaceButton = document.getElementById('connectCodespaceButton');

                if (!connectServerButton.disabled) {
                    connectServerButton.click();
                } else if (!authenticateButton.disabled) {
                    authenticateButton.click();
                } else if (!connectCodespaceButton.disabled) {
                    connectCodespaceButton.click();
                }
            }
        });
    </script>
</body>
</html>