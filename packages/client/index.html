<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimal Terminal Client</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
    <link href="https://cdn.jsdelivr.net/npm/@vscode/codicons@0.0.36/dist/codicon.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
        }

        body {
            background: #0f0f0f;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            background: #1e1e1e;
            border-bottom: 1px solid #333;
            padding: 8px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 40px;
            flex-shrink: 0;
        }
        
        .title {
            color: #cccccc;
            font-size: 13px;
            font-weight: 500;
        }
        
        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff6b6b;
            transition: background-color 0.3s ease;
        }
        
        .status-indicator.connected {
            background: #51cf66;
        }
        
        .status-text {
            color: #888;
            font-size: 12px;
        }
        
        .controls {
            display: flex;
            gap: 8px;
        }
        
        .control-button {
            background: #333;
            border: none;
            color: #ccc;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            transition: background-color 0.2s ease;
        }
        
        .control-button:hover {
            background: #444;
        }
        
        .terminal-container {
            flex: 1; /* Allow it to grow within the body's flex column */
            background: #0f0f0f;
            overflow: hidden; /* Hide scrollbars if content overflows */
            position: relative; /* Added for xterm.js to correctly position elements */
            padding: 8px; /* Keep padding here */
        }
        
        #terminal {
            height: 100%;
            width: 100%;
        }
        
        .xterm {
            height: 100%;
            width: 100%;
        }
        
        .connection-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .modal-content {
            background: #1e1e1e;
            padding: 24px;
            border-radius: 8px;
            border: 1px solid #333;
            min-width: 400px;
        }
        
        .modal-title {
            color: #fff;
            margin-bottom: 16px;
            font-size: 16px;
        }
        
        .form-group {
            margin-bottom: 16px;
        }
        
        .form-label {
            display: block;
            color: #ccc;
            margin-bottom: 4px;
            font-size: 12px;
        }
        
        .form-input {
            width: 100%;
            padding: 8px;
            background: #2d2d2d;
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
            font-size: 13px;
        }
        
        .form-input:focus {
            outline: none;
            border-color: #007acc;
        }
        
        .modal-buttons {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }
        
        .modal-button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }
        
        .modal-button.primary {
            background: #007acc;
            color: white;
        }
        
        .modal-button.secondary {
            background: #333;
            color: #ccc;
        }
        
        .modal-button:hover {
            opacity: 0.9;
        }
        
        .hidden {
            display: none;
        }

        .statusbar-item {
            position: fixed;
            bottom: 0;
            left: 0;
            height: 22px;
            line-height: 22px;
            cursor: default;
            color: #fff;
            padding: 0 8px;
            white-space: nowrap;
            -webkit-user-select: none;
            user-select: none;
            background-color: #007acc;
        }
        .statusbar-item-label {
            color: #fff;
            text-decoration: none;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="title">Terminal Client</div>
        <div class="connection-status">
            <div class="status-indicator" id="statusIndicator"></div>
            <span class="status-text" id="statusText">Disconnected</span>
        </div>
        <div class="controls">
            <input type="password" class="form-input" id="githubToken" placeholder="GitHub Token" style="width: 120px; margin-right: 8px;">
            <button class="control-button" id="authenticateButton">Authenticate</button>
            <button class="control-button" id="listCodespacesButton">List Codespaces</button>
            <select class="form-input" id="codespaceSelect" style="width: 150px; margin-right: 8px;">
                <option value="">--Select Codespace--</option>
            </select>
            <button class="control-button" id="connectCodespaceButton">Connect Codespace</button>
            <button class="control-button" id="toggleCodespaceStateButton" style="display: none;">Start Codespace</button>
            <button class="control-button" id="clearTerminalButton">Clear</button>
            <button class="control-button" id="showConnectionModalButton">Connect</button>
            <button class="control-button" id="reconnectButton">Reconnect</button>
            <button class="control-button" id="openGeminiButton">Open Gemini</button>
            <input type="text" class="form-input" id="repoUrlInput" placeholder="Repo URL (e.g., github.com/user/repo)" style="width: 250px; margin-left: 8px;">
            <button class="control-button" id="connectRepoCodespaceButton">Connect to Repo Codespace</button>
        </div>
    </div>
    
    <div class="terminal-container">
        <div id="terminal"></div>
    </div>
    
    <div class="connection-modal hidden" id="connectionModal">
        <div class="modal-content">
            <h3 class="modal-title">Connect to Remote Terminal</h3>
            <div class="form-group">
                <label class="form-label">Server URL</label>
                <input type="text" class="form-input" id="serverUrl" value="ws://localhost:3001" placeholder="ws://localhost:3001">
            </div>
            <div class="form-group">
                <label class="form-label">Authentication Token (optional)</label>
                <input type="password" class="form-input" id="authToken" placeholder="Enter authentication token">
            </div>
            <div class="modal-buttons">
                <button class="modal-button secondary" onclick="hideConnectionModal()">Cancel</button>
                <button class="modal-button primary" onclick="connectToServer()">Connect</button>
            </div>
        </div>
    </div>

    <div class="statusbar-item left remote-kind has-background-color first-visible-item" id="remote-status">
        <a class="statusbar-item-label" role="button">
            <span class="codicon codicon-remote"></span>
            <span id="remote-status-text">Open Remote</span>
        </a>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>
    <script>
        class MinimalTerminalClient {
            constructor() {
                this.terminal = null;
                this.socket = null;
                this.fitAddon = null;
                this.isConnected = false;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.currentCodespaceName = null;
                this.currentCodespaceState = null;
                this.currentRepositoryFullName = null;
                this.statusQueue = [];
                this.isProcessingStatusQueue = false;
                
                this.init();
            }

            processStatusQueue() {
                if (this.statusQueue.length === 0) {
                    this.isProcessingStatusQueue = false;
                    return;
                }

                this.isProcessingStatusQueue = true;
                const message = this.statusQueue.shift();
                const remoteStatusText = document.getElementById('remote-status-text');
                remoteStatusText.textContent = message;

                setTimeout(() => {
                    this.processStatusQueue();
                }, 3000);
            }

            addStatusMessage(message) {
                this.statusQueue.push(message);
                if (!this.isProcessingStatusQueue) {
                    this.processStatusQueue();
                }
            }
            
            init() {
                // Initialize xterm.js terminal
                this.terminal = new Terminal({
                    cursorBlink: true,
                    cursorStyle: 'block',
                    theme: {
                        background: '#0f0f0f',
                        foreground: '#ffffff',
                        cursor: '#ffffff',
                        selection: '#ffffff20',
                        black: '#000000',
                        red: '#cd3131',
                        green: '#0dbc79',
                        yellow: '#e5e510',
                        blue: '#2472c8',
                        magenta: '#bc3fbc',
                        cyan: '#11a8cd',
                        white: '#e5e5e5',
                        brightBlack: '#666666',
                        brightRed: '#f14c4c',
                        brightGreen: '#23d18b',
                        brightYellow: '#f5f543',
                        brightBlue: '#3b8eea',
                        brightMagenta: '#d670d6',
                        brightCyan: '#29b8db',
                        brightWhite: '#e5e5e5'
                    },
                    fontSize: 14,
                    fontFamily: 'Monaco, Menlo, "Ubuntu Mono", monospace',
                    lineHeight: 1.2
                });
                
                // Initialize fit addon for proper sizing
                this.fitAddon = new FitAddon.FitAddon();
                this.terminal.loadAddon(this.fitAddon);
                
                // Open terminal in the container
                const terminalContainer = document.getElementById('terminal');
                this.terminal.open(terminalContainer);
                
                // Delay fit to ensure container has rendered its size
                setTimeout(() => {
                    console.log(`[DEBUG] Before fit: terminalContainer.offsetHeight=${terminalContainer.offsetHeight}, terminalContainer.offsetWidth=${terminalContainer.offsetWidth}`);
                    this.fitAddon.fit();
                    console.log(`[DEBUG] After fit: cols=${this.terminal.cols}, rows=${this.terminal.rows}`);
                }, 100); // Small delay
                
                // Handle terminal input
                this.terminal.onData((data) => {
                    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                        this.socket.send(JSON.stringify({
                            type: 'input',
                            data: data
                        }));
                    }
                });
                
                // Handle window resize and container resize
                const resizeObserver = new ResizeObserver(entries => {
                    for (let entry of entries) {
                        if (entry.target === terminalContainer) {
                            this.fitAddon.fit();
                            console.log(`[DEBUG] Terminal resized by ResizeObserver: cols=${this.terminal.cols}, rows=${this.terminal.rows}`);
                        }
                    }
                });
                resizeObserver.observe(terminalContainer);

                window.addEventListener('resize', () => {
                    this.fitAddon.fit();
                    console.log(`[DEBUG] Terminal resized by window resize: cols=${this.terminal.cols}, rows=${this.terminal.rows}`);
                });
                
                // Welcome message
                this.terminal.writeln('\x1b[1;34mMinimal Terminal Client\x1b[0m');
                this.terminal.writeln('\x1b[90mClick "Connect" to establish a connection to a remote terminal.\x1b[0m');
                this.terminal.writeln('');
            }
            
            connect(url, token = '') {
                if (this.socket) {
                    this.socket.close();
                }
                
                this.updateStatus('Connecting...', false);
                
                try {
                    this.socket = new WebSocket(url);
                    
                    this.socket.onopen = () => {
                        this.isConnected = true;
                        this.reconnectAttempts = 0;
                        this.updateStatus('Connected', true);
                        
                        // Send authentication if provided
                        if (token) {
                            this.authenticate(token);
                        }
                        
                        // Query codespace status after connecting to server
                        this.socket.send(JSON.stringify({ type: 'query_codespace_status' }));
                        
                        this.terminal.writeln('\x1b[32m\u2713 Connected to remote terminal\x1b[0m');
                        this.addStatusMessage('Connected to remote terminal');
                    };
                    
                    this.socket.onmessage = (event) => {
                        try {
                            const message = JSON.parse(event.data);
                            this.handleMessage(message);
                        } catch (e) {
                            // Handle raw data
                            this.terminal.write(event.data);
                        }
                    };
                    
                    this.socket.onclose = () => {
                        this.isConnected = false;
                        this.updateStatus('Disconnected', false);
                        this.terminal.writeln('\r\n\x1b[31m\u2717 Connection closed\x1b[0m');
                        
                        // Auto-reconnect logic
                        if (this.reconnectAttempts < this.maxReconnectAttempts) {
                            this.reconnectAttempts++;
                            this.terminal.writeln(`\x1b[33mReconnecting... (${this.reconnectAttempts}/${this.maxReconnectAttempts})\x1b[0m`);
                            setTimeout(() => this.connect(url, token), 2000);
                        }
                    };
                    
                    this.socket.onerror = (error) => {
                        this.updateStatus('Connection Error', false);
                        this.terminal.writeln('\r\n\x1b[31m\u2717 Connection error\x1b[0m');
                    };
                    
                } catch (error) {
                    this.updateStatus('Connection Error', false);
                    this.terminal.writeln('\r\n\x1b[31m\u2717 Invalid WebSocket URL\x1b[0m');
                }
            }

            authenticate(token) {
                if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                    this.socket.send(JSON.stringify({
                        type: 'authenticate',
                        token: token
                    }));
                    this.terminal.writeln('\x1b[34mAuthenticating...\x1b[0m');
                } else {
                    this.terminal.writeln('\x1b[31mNot connected to server. Please connect first.\x1b[0m');
                }
            }

            listCodespaces() {
                if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                    this.socket.send(JSON.stringify({
                        type: 'list_codespaces'
                    }));
                    this.terminal.writeln('\x1b[34mRequesting codespaces list...\x1b[0m');
                } else {
                    this.terminal.writeln('\x1b[31mNot connected to server. Please connect first.\x1b[0m');
                }
            }

            connectToCodespace(codespaceName) {
                if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                    this.socket.send(JSON.stringify({
                        type: 'connect_codespace',
                        codespace_name: codespaceName
                    }));
                    this.terminal.writeln(`\x1b[34mConnecting to codespace: ${codespaceName}...\x1b[0m`);
                    this.addStatusMessage(`Connecting to codespace: ${codespaceName}...`);
                } else {
                    this.terminal.writeln('\x1b[31mNot connected to server. Please connect first.\x1b[0m');
                }
            }

            disconnectFromCodespace() {
                if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                    this.socket.send(JSON.stringify({
                        type: 'disconnect_codespace'
                    }));
                    this.terminal.writeln('\x1b[34mDisconnecting from codespace...\x1b[0m');
                } else {
                    this.terminal.writeln('\x1b[31mNot connected to server. Please connect first.\x1b[0m');
                }
            }

            startCodespace(codespaceName) {
                if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                    this.socket.send(JSON.stringify({
                        type: 'start_codespace',
                        codespace_name: codespaceName
                    }));
                    this.terminal.writeln(`\x1b[34mStarting codespace: ${codespaceName}...\x1b[0m`);
                } else {
                    this.terminal.writeln('\x1b[31mNot connected to server. Please connect first.\x1b[0m');
                }
            }

            stopCodespace(codespaceName) {
                if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                    this.socket.send(JSON.stringify({
                        type: 'stop_codespace',
                        codespace_name: codespaceName
                    }));
                    this.terminal.writeln(`\x1b[34mStopping codespace: ${codespaceName}...\x1b[0m`);
                } else {
                    this.terminal.writeln('\x1b[31mNot connected to server. Please connect first.\x1b[0m');
                }
            }
            
            handleMessage(message) {
                switch (message.type) {
                    case 'output':
                        this.terminal.write(message.data);
                        break;
                    case 'error':                        this.terminal.writeln(`
[31mError: ${message.message}[0m`);                        if (message.message.includes('Terminal session ended')) {                            this.addStatusMessage('Terminal session ended.');                        } else if (message.message === 'Bad credentials') {                            this.addStatusMessage('Error: Bad credentials');                        } else if (message.message === 'Not authenticated') {                            this.addStatusMessage('Connected: Not authenticated');                        }                        break;
                    case 'authenticated':
                        this.terminal.writeln('\x1b[32m\u2713 Authenticated successfully\x1b[0m');
                        this.addStatusMessage('Connected: Authenticated');
                        // Automatically list codespaces after authentication
                        this.listCodespaces();
                        break;
                    case 'codespaces_list':
                        const codespaces = message.data;
                        const codespaceSelect = document.getElementById('codespaceSelect');
                        codespaceSelect.innerHTML = '<option value="">--Select Codespace--</option>'; // Clear existing options
                        if (codespaces && codespaces.length > 0) {
                            codespaces.forEach(codespace => {
                                const option = document.createElement('option');
                                option.value = codespace.name;
                                option.textContent = codespace.name;
                                codespaceSelect.appendChild(option);
                            });
                            this.terminal.writeln(`\x1b[32m\u2713 Found ${codespaces.length} codespace(s).\x1b[0m`);
                            this.addStatusMessage(`Connected: ${codespaces.length} Codespace(s) available`);
                        } else {
                            this.terminal.writeln('\x1b[33mNo codespaces found.\x1b[0m');
                        }
                        // After listing, if a codespace was previously selected, try to re-select it
                        if (this.currentCodespaceName) {
                            codespaceSelect.value = this.currentCodespaceName;
                            this.updateCodespaceUI(this.currentCodespaceState);
                        }
                        break;
                    case 'codespace_state':
                        this.currentCodespaceName = message.codespace_name;
                        this.currentCodespaceState = message.state;
                        this.currentRepositoryFullName = message.repository_full_name;
                        this.terminal.writeln(`\r\n\x1b[32mCodespace '${this.currentCodespaceName}' state: ${this.currentCodespaceState}\x1b[0m`);
                        this.updateCodespaceUI(message.state);
                        break;
                    case 'codespace_connection_status':
                        this.currentCodespaceName = message.codespace_name;
                        this.currentCodespaceState = message.state;
                        this.terminal.writeln(`\r\n\x1b[32mCodespace connection status: ${this.currentCodespaceState}\x1b[0m`);
                        this.updateCodespaceUI(message.state);
                        break;
                    default:
                        console.log('Unknown message type:', message);
                }
            }
            
            updateStatus(text, connected) {
                const indicator = document.getElementById('statusIndicator');
                const statusText = document.getElementById('statusText');
                const remoteStatusText = document.getElementById('remote-status-text');
                const showConnectionModalButton = document.getElementById('showConnectionModalButton');

                statusText.textContent = text;
                
                if (connected) {
                    indicator.classList.add('connected');
                    showConnectionModalButton.textContent = 'Disconnect';
                } else {
                    indicator.classList.remove('connected');
                    remoteStatusText.textContent = 'Not Connected';
                    showConnectionModalButton.textContent = 'Connect';
                    if (this.reconnectAttempts === 0) {
                        showConnectionModal();
                    }
                }
            }

            updateCodespaceUI(state) {
                const connectCodespaceButton = document.getElementById('connectCodespaceButton');
                const toggleCodespaceStateButton = document.getElementById('toggleCodespaceStateButton');
                const codespaceSelect = document.getElementById('codespaceSelect');
                const remoteStatus = document.getElementById('remote-status');
                const remoteStatusText = document.getElementById('remote-status-text');

                if (state === 'Connected') {
                    connectCodespaceButton.textContent = 'Disconnect Codespace';
                    connectCodespaceButton.disabled = false;
                    toggleCodespaceStateButton.style.display = 'inline-block';
                    toggleCodespaceStateButton.textContent = 'Stop Codespace';
                    toggleCodespaceStateButton.disabled = false;
                    codespaceSelect.disabled = true;
                    remoteStatusText.textContent = `Connected: ${this.currentCodespaceName}`;

                    const codespaceNameParts = this.currentCodespaceName.split('-');
                    codespaceNameParts.pop(); // Omit the last word
                    const formattedCodespaceName = codespaceNameParts.join(' ');

                    remoteStatusText.textContent = `Connected: ${formattedCodespaceName}`;
                    remoteStatus.title = `Editing on '${formattedCodespaceName}' (${this.currentRepositoryFullName})`;
                } else if (state === 'Shutdown') {
                    connectCodespaceButton.textContent = 'Connect Codespace';
                    connectCodespaceButton.disabled = false;
                    toggleCodespaceStateButton.style.display = 'inline-block';
                    toggleCodespaceStateButton.textContent = 'Start Codespace';
                    toggleCodespaceStateButton.disabled = false;
                    codespaceSelect.disabled = false;
                    remoteStatusText.textContent = 'Authenticated';
                } else if (state === 'Starting') {
                    connectCodespaceButton.textContent = 'Connect Codespace';
                    connectCodespaceButton.disabled = true;
                    toggleCodespaceStateButton.style.display = 'inline-block';
                    toggleCodespaceStateButton.textContent = 'Starting...';
                    toggleCodespaceStateButton.disabled = true;
                    codespaceSelect.disabled = true;
                    remoteStatusText.textContent = 'Authenticated';
                } else if (state === 'Stopping') {
                    connectCodespaceButton.textContent = 'Connect Codespace';
                    connectCodespaceButton.disabled = true;
                    toggleCodespaceStateButton.style.display = 'inline-block';
                    toggleCodespaceStateButton.textContent = 'Stopping...';
                    toggleCodespaceStateButton.disabled = true;
                    codespaceSelect.disabled = true;
                    remoteStatusText.textContent = 'Authenticated';
                } else {
                    // Default or Disconnected state
                    connectCodespaceButton.textContent = 'Connect Codespace';
                    connectCodespaceButton.disabled = false;
                    toggleCodespaceStateButton.style.display = 'none';
                    codespaceSelect.disabled = false;
                    remoteStatusText.textContent = 'Not Connected';
                }
            }
            
            clear() {
                this.terminal.clear();
            }
            
            reconnect() {
                if (this.isConnected) {
                    this.terminal.writeln('\x1b[33mAlready connected.\x1b[0m');
                    return;
                }
                const url = document.getElementById('serverUrl').value;
                const token = document.getElementById('authToken').value;
                this.connect(url, token);
            }
        }
        
        // Global terminal client instance
        let terminalClient;
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            terminalClient = new MinimalTerminalClient();

            const remoteStatus = document.getElementById('remote-status');
            remoteStatus.addEventListener('click', () => {
                showConnectionModal();
            });

            const githubTokenInput = document.getElementById('githubToken');
            const authenticateButton = document.getElementById('authenticateButton');
            const listCodespacesButton = document.getElementById('listCodespacesButton');
            const codespaceSelect = document.getElementById('codespaceSelect');
            const connectCodespaceButton = document.getElementById('connectCodespaceButton');
            const toggleCodespaceStateButton = document.getElementById('toggleCodespaceStateButton');
            const showConnectionModalButton = document.getElementById('showConnectionModalButton');

            authenticateButton.addEventListener('click', () => {
                const token = githubTokenInput.value;
                if (token) {
                    terminalClient.authenticate(token);
                } else {
                    alert('Please enter a GitHub Token.');
                }
            });

            listCodespacesButton.addEventListener('click', () => {
                terminalClient.listCodespaces();
            });

            codespaceSelect.addEventListener('change', () => {
                const codespaceName = codespaceSelect.value;
                if (codespaceName) {
                    // When a codespace is selected, update the UI to reflect its potential state
                    // This assumes we have the state available from a previous list_codespaces call
                    // For now, we'll just reset the buttons to default connect/start state
                    terminalClient.currentCodespaceName = codespaceName;
                    terminalClient.updateCodespaceUI('Shutdown'); // Assume shutdown initially for a newly selected codespace
                } else {
                    terminalClient.currentCodespaceName = null;
                    terminalClient.updateCodespaceUI('Disconnected');
                }
            });

            connectCodespaceButton.addEventListener('click', () => {
                const codespaceName = codespaceSelect.value;
                if (!codespaceName) {
                    alert('Please select a Codespace.');
                    return;
                }

                if (terminalClient.currentCodespaceState === 'Connected') {
                    terminalClient.disconnectFromCodespace();
                } else {
                    terminalClient.connectToCodespace(codespaceName);
                }
            });

            toggleCodespaceStateButton.addEventListener('click', () => {
                const codespaceName = codespaceSelect.value;
                if (!codespaceName) {
                    alert('Please select a Codespace.');
                    return;
                }

                if (terminalClient.currentCodespaceState === 'Shutdown') {
                    terminalClient.startCodespace(codespaceName);
                } else if (terminalClient.currentCodespaceState === 'Connected') {
                    terminalClient.stopCodespace(codespaceName);
                }
            });

            // Initial UI update
            terminalClient.updateCodespaceUI('Disconnected');

            const openGeminiButton = document.getElementById('openGeminiButton');
            openGeminiButton.addEventListener('click', () => {
                terminalClient.terminal.writeln('npx https://github.com/google-gemini/gemini-cli\r');
            });

            const repoUrlInput = document.getElementById('repoUrlInput');
            const connectRepoCodespaceButton = document.getElementById('connectRepoCodespaceButton');

            connectRepoCodespaceButton.addEventListener('click', () => {
                const repoUrl = repoUrlInput.value;
                if (!repoUrl) {
                    alert('Please enter a repository URL.');
                    return;
                }
                if (terminalClient.socket && terminalClient.socket.readyState === WebSocket.OPEN) {
                    terminalClient.socket.send(JSON.stringify({
                        type: 'connect_to_repo_codespace',
                        repo_url: repoUrl
                    }));
                    terminalClient.terminal.writeln(`\x1b[34mRequesting codespace for repository: ${repoUrl}...\x1b[0m`);
                } else {
                    terminalClient.terminal.writeln('\x1b[31mNot connected to server. Please connect first.\x1b[0m');
                }
            });

            // Add event listeners for the new buttons
            document.getElementById('clearTerminalButton').addEventListener('click', () => {
                terminalClient.clear();
            });

            showConnectionModalButton.addEventListener('click', () => {
                if (terminalClient.isConnected) {
                    terminalClient.socket.close();
                } else {
                    showConnectionModal();
                }
            });

            document.getElementById('reconnectButton').addEventListener('click', () => {
                terminalClient.reconnect();
            });
        });
        
        // Modal functions
        function showConnectionModal() {
            document.getElementById('connectionModal').classList.remove('hidden');
        }
        
        function hideConnectionModal() {
            document.getElementById('connectionModal').classList.add('hidden');
        }
        
        function connectToServer() {
            const url = document.getElementById('serverUrl').value;
            const token = document.getElementById('authToken').value;
            
            if (!url) {
                alert('Please enter a server URL');
                return;
            }
            
            terminalClient.connect(url, token);
            hideConnectionModal();
        }
        
        function clearTerminal() {
            terminalClient.clear();
        }
        
        function reconnect() {
            terminalClient.reconnect();
        }
        
        // Handle Enter key in modal
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !document.getElementById('connectionModal').classList.contains('hidden')) {
                connectToServer();
            }
        });
    </script>
</body>
</html>